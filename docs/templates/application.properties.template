# ============================================
# APPLICATION PROPERTIES - 3-LAYER ARCHITECTURE
# Copy this to src/main/resources/application.properties
# Replace placeholders with your actual values
# ============================================

# ===== SERVER CONFIGURATION =====
server.port=8080
spring.application.name=valetkey

# ===== DATABASE CONFIGURATION =====
spring.datasource.url=jdbc:mysql://localhost:3306/valetkey_db
spring.datasource.username=YOUR_DB_USERNAME
spring.datasource.password=YOUR_DB_PASSWORD
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.format_sql=true

# HikariCP Connection Pool
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.leak-detection-threshold=60000

# ===== AZURE BLOB STORAGE =====
azure.storage.connection-string=YOUR_AZURE_CONNECTION_STRING
azure.storage.container-name=valet-demo

# ===== FILE UPLOAD CONFIGURATION =====
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=100MB
spring.servlet.multipart.max-request-size=100MB

# ===== CACHE CONFIGURATION (Caffeine) =====
# Note: Individual cache TTL is configured in CacheConfig.java
# This is just the default cache type
spring.cache.type=caffeine

# Cache Strategy (Best Practice):
# - sasUrls: 9 min (SAS URL expiry - 1 min)
# - fileMetadata: 15 min (rarely changes)
# - fileList: 1 min (frequently changes, user needs real-time view)
# - userStorage: 1 min (critical for quota enforcement)
# - folderTree: 5 min (less frequent than files)
# - searchResults: 2 min (balance performance & freshness)

# ===== CIRCUIT BREAKER CONFIGURATION (Resilience4j) - BEST PRACTICE =====
# Azure Service Circuit Breaker
resilience4j.circuitbreaker.instances.azureService.registerHealthIndicator=true

# Sliding window: Track last 10 calls
resilience4j.circuitbreaker.instances.azureService.slidingWindowSize=10

# Need at least 5 calls before calculating failure rate
resilience4j.circuitbreaker.instances.azureService.minimumNumberOfCalls=5

# Open circuit if 50% of calls fail (Best Practice: 40-60%)
resilience4j.circuitbreaker.instances.azureService.failureRateThreshold=50

# Open circuit if 50% of calls are slow (Best Practice: 40-60%)
resilience4j.circuitbreaker.instances.azureService.slowCallRateThreshold=50

# Calls > 5s are considered slow (adjust based on your SLA)
resilience4j.circuitbreaker.instances.azureService.slowCallDurationThreshold=5s

# Wait 30s before trying again (Best Practice: 30-60s)
resilience4j.circuitbreaker.instances.azureService.waitDurationInOpenState=30s

# Test with 3 calls when recovering (Best Practice: 2-5)
resilience4j.circuitbreaker.instances.azureService.permittedNumberOfCallsInHalfOpenState=3

# Automatically transition from OPEN to HALF_OPEN
resilience4j.circuitbreaker.instances.azureService.automaticTransitionFromOpenToHalfOpenEnabled=true

# Read Operations Circuit Breaker (More lenient)
resilience4j.circuitbreaker.instances.azureRead.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.azureRead.slidingWindowSize=10
resilience4j.circuitbreaker.instances.azureRead.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.azureRead.failureRateThreshold=70
resilience4j.circuitbreaker.instances.azureRead.waitDurationInOpenState=15s
resilience4j.circuitbreaker.instances.azureRead.slowCallDurationThreshold=3s

# Write Operations Circuit Breaker (More strict)
resilience4j.circuitbreaker.instances.azureWrite.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.azureWrite.slidingWindowSize=10
resilience4j.circuitbreaker.instances.azureWrite.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.azureWrite.failureRateThreshold=30
resilience4j.circuitbreaker.instances.azureWrite.waitDurationInOpenState=60s
resilience4j.circuitbreaker.instances.azureWrite.slowCallDurationThreshold=10s

# ===== RETRY CONFIGURATION (Resilience4j) - BEST PRACTICE =====
# Azure Service Retry with Exponential Backoff

# Try up to 3 times (1 original + 2 retries) - Best Practice: 2-4
resilience4j.retry.instances.azureService.maxAttempts=3

# Wait 1s before first retry - Best Practice: 500ms-2s
resilience4j.retry.instances.azureService.waitDuration=1s

# Enable exponential backoff (1s → 2s → 4s)
resilience4j.retry.instances.azureService.enableExponentialBackoff=true

# Double wait time each retry - Best Practice: 1.5-3
resilience4j.retry.instances.azureService.exponentialBackoffMultiplier=2

# Only retry these exceptions (transient failures)
resilience4j.retry.instances.azureService.retryExceptions=java.io.IOException,com.azure.core.exception.AzureException,java.net.SocketTimeoutException

# Never retry these exceptions (business logic errors)
resilience4j.retry.instances.azureService.ignoreExceptions=java.lang.IllegalArgumentException

# Critical Operations Retry (More aggressive)
resilience4j.retry.instances.azureCritical.maxAttempts=5
resilience4j.retry.instances.azureCritical.waitDuration=500ms
resilience4j.retry.instances.azureCritical.enableExponentialBackoff=true
resilience4j.retry.instances.azureCritical.exponentialBackoffMultiplier=2
resilience4j.retry.instances.azureCritical.retryExceptions=java.io.IOException,com.azure.core.exception.AzureException

# Non-Critical Operations Retry (Less aggressive)
resilience4j.retry.instances.azureNonCritical.maxAttempts=2
resilience4j.retry.instances.azureNonCritical.waitDuration=500ms
resilience4j.retry.instances.azureNonCritical.enableExponentialBackoff=false
resilience4j.retry.instances.azureNonCritical.retryExceptions=java.io.IOException

# ===== ACTUATOR CONFIGURATION (Health Monitoring) =====
# Expose health and monitoring endpoints
management.endpoints.web.exposure.include=health,metrics,prometheus,circuitbreakers,ratelimiters,caches,info

# Show detailed health information (only for authenticated users)
management.endpoint.health.show-details=when-authorized

# Enable specific health indicators
management.health.defaults.enabled=true
management.health.db.enabled=true
management.health.diskSpace.enabled=true

# Custom health endpoint path
management.endpoints.web.base-path=/actuator

# ===== ASYNC CONFIGURATION =====
# Thread pool for async uploads
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=10
spring.task.execution.pool.queue-capacity=100
spring.task.execution.thread-name-prefix=async-upload-

# ===== LOGGING CONFIGURATION =====
logging.level.root=INFO
logging.level.com.example.valetkey=DEBUG
logging.level.io.github.resilience4j=DEBUG
logging.level.org.springframework.cache=DEBUG
logging.level.com.azure.storage=WARN

# Log file configuration
logging.file.name=logs/application.log
logging.file.max-size=10MB
logging.file.max-history=30

# ===== SCHEDULED TASKS =====
# Orphaned file cleanup runs every 6 hours
spring.task.scheduling.pool.size=2

# ===== SESSION CONFIGURATION =====
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false

# ===== CORS CONFIGURATION (if needed) =====
# cors.allowed-origins=http://localhost:3000
# cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
# cors.allowed-headers=*

# ===== PRODUCTION OVERRIDES (Uncomment for production) =====
# server.servlet.session.cookie.secure=true
# management.endpoint.health.show-details=never
# logging.level.com.example.valetkey=INFO
# spring.jpa.show-sql=false

