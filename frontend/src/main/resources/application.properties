spring.application.name=valetKey

#spring.datasource.driver-class-name=org.postgresql.Driver
## Disable prepared statement caching to avoid "prepared statement already exists" error
## This is needed for Supabase Transaction mode connection pooling
#spring.datasource.url=jdbc:postgresql://aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres?prepareThreshold=0&preparedStatementCacheQueries=0
#spring.datasource.username=postgres.kelsjjbbiasblwqccpbt
#spring.datasource.password=123456




# Connection Pool Configuration (HikariCP)
# Transaction mode (port 6543) allows more connections than Session mode
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.idle-timeout=180000
spring.datasource.hikari.max-lifetime=600000
spring.datasource.hikari.leak-detection-threshold=15000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.pool-name=ValetKeyHikariPool
spring.datasource.hikari.auto-commit=true

# JPA/Hibernate Configuration
#spring.jpa.show-sql=false
# Transaction mode (port 6543) allows more connections, safe to use 'update'
# Hibernate will create missing tables automatically
#spring.jpa.hibernate.ddl-auto=update
#spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
#spring.jpa.properties.hibernate.globally_quoted_identifiers=true
#spring.jpa.properties.hibernate.globally_quoted_identifiers_skip_column_definitions=true

# Close idle connections
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=false
spring.jpa.properties.hibernate.connection.handling_mode=delayed_acquisition_and_release_after_transaction

# Force flush and clear to release connections faster
spring.jpa.properties.hibernate.flush_mode=commit
spring.jpa.properties.hibernate.jdbc.batch_size=20

# File Upload Configuration - Allow large files up to 1GB
spring.servlet.multipart.max-file-size=1GB
spring.servlet.multipart.max-request-size=1GB
spring.servlet.multipart.file-size-threshold=10MB
spring.servlet.multipart.resolve-lazily=true

# HTTP Request timeout for large files (extended for 1GB files)
server.tomcat.connection-timeout=600000
server.tomcat.max-swallow-size=1GB

azure.storage.connection-string=${AZURE_CONNECTION_STRING}
azure.storage.container-name=valet-demo

management.endpoints.web.exposure.include=health,metrics,prometheus,circuitbreakers,ratelimiters
management.endpoint.metrics.enabled=true
management.endpoint.health.show-details=always
management.health.circuitbreakers.enabled=true
management.health.ratelimiters.enabled=true

# ===== CIRCUIT BREAKER CONFIGURATION (Resilience4j) - BEST PRACTICE =====
# Azure Service Circuit Breaker
resilience4j.circuitbreaker.instances.azureService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.azureService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.azureService.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.azureService.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.azureService.automaticTransitionFromOpenToHalfOpenEnabled=true
resilience4j.circuitbreaker.instances.azureService.waitDurationInOpenState=30s
resilience4j.circuitbreaker.instances.azureService.failureRateThreshold=50
resilience4j.circuitbreaker.instances.azureService.slowCallRateThreshold=50
resilience4j.circuitbreaker.instances.azureService.slowCallDurationThreshold=5s

# ===== RETRY CONFIGURATION (Resilience4j) - BEST PRACTICE =====
# Azure Service Retry with Exponential Backoff
resilience4j.retry.instances.azureService.maxAttempts=3
resilience4j.retry.instances.azureService.waitDuration=1s
resilience4j.retry.instances.azureService.enableExponentialBackoff=true
resilience4j.retry.instances.azureService.exponentialBackoffMultiplier=2
resilience4j.retry.instances.azureService.retryExceptions=java.io.IOException,com.azure.core.exception.AzureException,java.net.SocketTimeoutException
resilience4j.retry.instances.azureService.ignoreExceptions=java.lang.IllegalArgumentException

# ===== CACHE CONFIGURATION (Caffeine) - BEST PRACTICE =====
# Individual cache TTL configured in CacheConfig.java
spring.cache.type=caffeine

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret

# Hibernate
spring.jpa.hibernate.ddl-auto=update

# Ch?n Dialect MySQL
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
# Ho?c d�ng:
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# T�y ch?n cho t�n b?ng/c?t n?u mu?n quote
spring.jpa.properties.hibernate.globally_quoted_identifiers=true
spring.jpa.properties.hibernate.globally_quoted_identifiers_skip_column_definitions=true